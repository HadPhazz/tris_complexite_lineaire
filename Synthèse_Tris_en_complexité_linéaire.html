<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tris en complexité linéaire.md</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <link rel="stylesheet" href="md.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><hr>
<h2 id="title-synthèse--tris-en-complexité-linéaire">title: Synthèse : Tris en complexité linéaire</h2>
<h1 id="tris-en-complexité-linéaire">Tris en complexité linéaire</h1>
<h2 id="types-de-tris">Types de tris</h2>
<p>Il existe plusieurs algorithmes de tri, qui permettent d’ordonner des <strong>collections d’objets</strong> (qu’elles soient composées de nombres, de chaines de caractères, …) selon une relation d’ordre déterminée. Ces <a href="https://en.wikipedia.org/wiki/Sorting_algorithm">algorithmes</a> sont répartis en deux catégories : Ceux effectuant des comparaison entre les éléments d’une structure de donnée, et ceux n’en effectuant pas. Il existe aussi certains algorithmes dits “hybrides”, et d’autres, très spécifiques, tel le tri <a href="https://en.wikipedia.org/wiki/Spaghetti_sort">Spaghetti</a>, qui sont aussi répertoriés à part, mais nous ne les aborderont pas au cours de cette synthèse.</p>
<p>Ces algorithmes, qu’ils fonctionnent par sélection, par insertion, par fusionnement, ou bien par distribution, ont tous des <strong>complexités temporelles et spatiales différentes</strong>, et, en fonction de leurs usages, il conviendront ou non à la réalisation efficace d’un tri sur une collection d’objets donnée.</p>
<p>On peut aussi organiser les algorithmes de tri selon deux critères, qui permettent d’identifier, en partie, leur mode de fonctionnement. On distingue notamment :</p>
<ul>
<li>
<p>Le <strong>tri en place</strong>, qui est un algorithme utilisant un nombre limité de variables, <strong>opérant directement sur la collection d’objets</strong> passée en paramètre. Cette dernière spécification est importante, parce qu’elle permet de l’imiter l’impact de l’algorithme sur la mémoire de la machine l’exécutant.</p>
</li>
<li>
<p>Le <strong>tri stable</strong>, qui est un algorithme <strong>préservant l’organisation initiale des éléments égaux</strong> de la collection d’objets sur laquelle il opère. Les éléments égaux peuvent être des chiffres, des caractères, des symboles, … Un tri stable voit sa complexité temporelle améliorée, mais il faudra bien souvent un espace mémoire plus conséquent afin de stocker l’ordre initial des éléments.</p>
</li>
</ul>
<p>Qu’ils soient stables ou en place, tous les algorithmes de tri peuvent être parallélisés, afin de limiter leur temps d’exécution, notamment quand la quantité de données à trier est trop importante pour être effectuée par une seule machine.</p>
<h2 id="problème-du-tri">Problème du tri</h2>
<p>Le problème du tri est inhérent à l’application des tris sur des collections d’objets : il faut obtenir une collection d’objets finale, regroupant les mêmes objets initiaux, dans laquelle un élément est toujours “plus petit” que tous ceux qui le succèdent. Cette notion de taille est relative, elle dépends de la clé de comparaison donnée en paramètre du tri (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo separator="true">,</mo><mo>&lt;</mo><mo separator="true">,</mo><mo>&gt;</mo><mo separator="true">,</mo><mo>≤</mo><mo separator="true">,</mo><mo>≥</mo></mrow><annotation encoding="application/x-tex">=, \lt, \gt ,\leq, \geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height: 0.83041em; vertical-align: -0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span></span><span class="base"><span class="strut" style="height: 0.83041em; vertical-align: -0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span></span></span></span></span>, selon que l’on veuille arranger les éléments par ordre croissant ou décroissant).<br>
Evidemment, pour les tris n’opérant par comparaison, il s’agit de trier les éléments selon un critère donné, spécifique au tri concerné. Ce critère peut être lié à la fréquence d’apparition, la position, le contenu (tel l’ordre des chiffres significatifs d’un nombre), le “poids”, … On cherchera également à réduire le temps d’exécution de ces algorithmes et la quantité de mémoire à laquelle ils ont recours en implémentant diverses stratégies d’optimisation.</p>
<h2 id="tris-par-comparaison">Tris par comparaison</h2>
<p>Les tris par comparaison sont des algorithmes effectuant, à une étape donnée,  une comparaison entre deux éléments distincts d’une collection d’objets.<br>
L’opération de comparaison utilisée par ces tris est généralement <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="mrel">≤</span></span></span></span></span>, elle sert à déterminer quel élément devra apparaitre en premier dans la collection triée (ici, la notion d’infériorité/d’égalité est relative, elle s’applique au entiers mais pas aux mots par exemple, on utilisera pour cela une fonction qui effectuera une liaison entre chaque caractère et un nombre déterminé, cf. ASCII).</p>
<p>Il existe plusieurs sous-catégories de tri par comparaison, dont les tris “naïfs”, et les tris utilisant la méthode “diviser pour régner” :</p>
<ul>
<li>
<p>Les algorithmes de tri naïf n’ont pas besoin de structures de données élaborées. Les deux tris naïfs les plus connus sont le tri par sélection et le tri par insertion. Ces deux tris partagent une complexité temporelle quadratique <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(O(n^2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span> dans le cas de collection d’objets arrangés aléatoirement, seul le tri par insertion opère en temps linéaire quand la liste d’éléments est triée par ordre croissant.</p>
</li>
<li>
<p>Les algorithmes utilisant la méthode “diviser pour régner” cherchent à diviser un problème initial en sous-problèmes indépendants; dans le cas des tris, ils s’agît de diviser la collection d’objets initiale en sous-collections, afin d’augmenter la rapidité de traitement des données.<br>
Les algorithmes de tri les plus connus, utilisant cette méthode, sont le tri rapide et le tri fusion. Le premier partitionne les sous structures d’éléments triés, tandis que le second se charge de leur fusion. Ces deux algorithmes possèdent une complexité temporelle quasi-linéaire <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(O(n\log n) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span> dans le meilleur des cas et dans les cas moyens, le tri rapide voit sa complexité temporelle passer en <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> dans le pire des cas.</p>
</li>
</ul>
<h2 id="tris-par-distribution">Tris par distribution</h2>
<p>Les tris par distribution sont des algorithmes opérant sur des données qui seront distribuées entre la collection d’objets initiale et des <strong>structures de données temporaires</strong>, durant le processus d’arrangement des éléments. Ces structures temporaires, bien souvent des listes, seront détruites une fois le tri des éléments réalisé.<br>
Ces algorithmes de tri sont généralement utilisés sur de larges <em>datasets</em> (collections d’objets), ne pouvant être regroupés dans la mémoire d’un seul système informatique. Ils peuvent donc être <strong>parallélisés</strong>, le processus de distribution permettant le traitement de sous-ensembles individuels de données peut être effectué sur différents processeurs, puis le processus de combinaison en une unique collection d’objets, à enregistrer en mémoire ou à présenter à l’écran, peut être réalisé une fois les étapes précédentes terminées .</p>
<p>Les algorithmes de tri opérant par distribution d’éléments les plus connus sont le tri par dénombrement, le tri par paquets et le tri par base :</p>
<ul>
<li>
<p>Le <strong>tri par dénombrement</strong> détermine, pour chaque élément donné, le nombre d’éléments inférieurs à ce dernier, selon une clé/relation d’ordre spécifiée. Ce tri opère utilise des sous-structures temporaires afin d’effectuer la distribution des éléments, mais sa complexité reste linéaire.</p>
</li>
<li>
<p>Le <strong>tri par base</strong> met à profit le tri par dénombrement, sa complexité est elle aussi linéaire. Nous décririons les spécifications de ce tri et son fonctionnement dans la partie de ce rapport prévue à cet effet.</p>
</li>
<li>
<p>Enfin, le <strong>tri par paquets</strong> distribue les éléments selon des clés définies sur l’intervalle <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding="application/x-tex">[0, 1[</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mopen">[</span></span></span></span></span>, et effectue par la suite une concaténation des paquets, afin d’obtenir la liste d’éléments triés. Ce tri est lui aussi en temps linéaire.</p>
</li>
</ul>
<p>De plus, ces trois tris sont stables, mais ils ne sont pas en place.</p>
<h2 id="tri-par-base---radix-sort">Tri par base - Radix Sort</h2>
<h3 id="description">Description</h3>
<p>Le <strong>tri par base</strong> (Radix Sort en anglais) est un algorithme de tri par distribution, utilisant le tri par dénombrement comme routine d’exécution, sur des listes de <strong>nombres entiers</strong> (naturels et relatifs), de <strong>nombres décimaux</strong> finis, mais aussi sur des listes de <strong>chaines de caractères</strong> (mots, emails, …).</p>
<p>Cet algorithme trie les données avec des clés selon l’ordre lexicographique, en les regroupant par des chiffres individuels qui partagent la même position significative et la même valeur.<br>
Le <strong>Radix</strong> (la base) est le nombre de digits utilisé pour représenter un nombre dans un système de numérotation positionnel. (2 pour le binaire, 8 pour l’octal, 10 pour le décimal, …).</p>
<p>Quelque soit le type des éléments de la liste passée en paramètre de cet algorithme, une clé, sous la forme d’un entier, sera associée à chaque digit.<br>
Les éléments ne seront donc pas triés d’une manière comparative, mais en fonction de leur base, et des chiffres significatifs qui les composent.</p>
<p>Il existe deux types de tri par base :</p>
<ul>
<li>
<p><strong>LSD Radix Sort</strong> (bit de poids faible / plus petit chiffre significatif) : Généralement utilisé pour les données numériques (entiers, flottants, …) en commençant par le chiffre des unités, puis celui des dizaines, … de la droite vers la gauche.</p>
</li>
<li>
<p><strong>MSD Radix Sort</strong> (bit de poids fort / plus grand chiffre significatif) : Généralement utilisé pour les données lexicographiques (mots, phrases, …) en triant les éléments dans le sens de lecture (de gauche à droite), du premier caractère rencontré jusqu’au dernier.</p>
</li>
</ul>
<p>Les deux versions peuvent traiter des données numériques et lexicographiques, cependant, la version MSD prends en charge des mots de longueur différente, à l’inverse de la version LSD.</p>
<p>Dans notre version du tri par base, les éléments sont triés avec les clés définies comme les chiffres significatifs qui composent les nombres. L’algorithme se décompose de la sorte :</p>
<ol>
<li>Prendre le <strong>chiffre le moins significatif</strong> comme clé (celui des unités à la première itération)</li>
<li><strong>Trier par comptage</strong> les éléments, en les ordonnant selon cette <strong>clé</strong> (processus de distribution)</li>
<li>Répéter avec les <strong>chiffres plus significatifs</strong> (ceux des dizaines, puis des centaines, …)</li>
</ol>
<p>Il faut, à chaque itération, placer les éléments dans des structures de données temporaires (listes, files, …) afin d’effectuer les opérations de distribution sur tous les éléments encore non triés.<br>
Ainsi, pour toute liste de nombres en base <em>n</em>, cet algorithme utilisera au maximum <em>n</em> structures de données temporaires, définies en fonction des chiffres significatifs.</p>
<blockquote>
<p>Par exemple, avec la liste l : [7, 11, 13, 70, 0, 171, 71], composée de sept nombres représentés en base dix, il faudra quatre structures de données temporaires pour effectuer le tri par base : seuls les chiffres 0, 1, 3, et 7 sont présents dans la liste, il y a donc quatre digits différents.</p>
</blockquote>
<p>L’algorithme de tri par base est utilisé dans la construction de <strong>tableau des suffixes</strong> par <a href="http://algo2.iti.kit.edu/documents/jacm05-revised.pdf">l’algorithme DC3</a> (notamment dans le domaine de la bio-informatique, avec l’alignement de séquences d’<a href="https://ieeexplore.ieee.org/abstract/document/7152610">ADN</a>.</p>
<h3 id="complexité">Complexité</h3>
<p>La <strong>complexité temporelle</strong> de cet algorithme sur une collection d’objets (nombres, chaines de caractère) est linéaire <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, quelque soit l’état de la liste (qu’elle soit arrangée aléatoirement, ou bien triée par ordre croissant/décroissant de valeurs, …), à l’inverse d’un tri par comparaison qui, dans des cas moyens (comprendre ici que la liste soit arrangée aléatoirement), verra son temps d’exécution borné à une complexité quasi-linéaire <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
<p>Le tri par base effectuera un nombre déterminé de passes de tri de comptage sur une liste donnée, qui sera dépendant du nombre de chiffres significatifs du plus grand entier de la liste.</p>
<blockquote>
<p>En gardant notre exemple, avec la liste l : [7, 11, 13, 70, 0, 171, 71], le nombre de plus grands chiffres significatifs est 171, il est composé de trois digits, il y aura donc trois passes afin de trier la liste selon un ordre croissant</p>
</blockquote>
<p>Sa <strong>complexité spatiale</strong> est elle aussi linéaire, il y’aura, au maximum, besoin de dix structures de données temporaires dans le cas où la liste serait composée de nombres, et de <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> structures de données temporaires pour des mots issus d’alphabets de <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> caractères.</p>
<blockquote>
<p>Il est possible de synthétiser ces information de la manière suivante :<br>
Complexité temporelle : <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O( d * (n+k))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mclose">))</span></span></span></span></span><br>
Complexité spatiale :  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span></span></span></span></span><br>
(où <strong><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">d</span></span></span></span></span></strong> est le nombre maximum de chiffre significatifs d’un nombre,  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> est la taille de la liste donnée et <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.03148em;">k</span></span></span></span></span> est le nombre de structures de données temporaires utilisées pour la distribution).</p>
</blockquote>
<h3 id="animation">Animation</h3>
<p>Cette animation, représentant le fonctionnement du tri par base sur une liste d’entiers positifs, se divise en plusieurs étapes. Nous avons fait le choix ici de dupliquer la liste afin de la garder en référence, pour avoir un rappel de sa composition initiale, avant tout traitement sur cette dernière. Les structures de données temporaires, utilisées pour la distribution, sont ici représentées par des files.</p>
<p>Voici une description de ce tri, en accord avec les étapes de l’animation :</p>
<ol>
<li>Choix du chiffre le moins significatif comme clé, ici le chiffre des unités, pour chaque nombre.</li>
<li>Distribution des éléments de la liste dans des files selon la clé définie à l’étape précédente.</li>
<li>Défilage des éléments selon l’ordre numérique croissant des files (ici de la file 0 à la file 7).</li>
<li>Choix du second chiffre le moins significatif, celui des dizaines, puis répétition de l’étape n°2.</li>
<li>Répétition de l’étape n°3.</li>
<li>Choix du troisième (et dernier) chiffre le moins significatif, celui des centaines, puis répétition de l’étape n°2</li>
<li>Répétition de l’étape n°3.</li>
<li>Destruction des zéros non significatifs placés devant les éléments pendant les opérations de distribution</li>
</ol>
<p><img src="img/radix_sort_demo.gif" alt="" title="Animation illustrant le fonctionnement de l'algorithme de tri par base"></p>
<p>Cet algorithme est évidemment simplifié dans notre animation, mais il serait tout à fait envisageable de produire une animation similaire sur des mots (RUE, BAR, BUS, HUB, BOL, EAU et ARC par exemple) de même taille ou non, en créant un nombre de files suffisant (26 au maximum, 10 dans notre exemple), afin de les ordonner de manière alphabétique.</p>
<h3 id="implémentation-en-python">Implémentation en Python</h3>
<p>L’implémentation en Python de ce tri est assez simple, vu qu’il se sert du tri par dénombrement pour effectuer la distribution des éléments. Voici une représentation de l’algorithme en base dix, selon la méthode LSD (Cet algorithme doit être utilisé sur des nombres, la clé (le chiffre significatif) étant le bit de poids faible).</p>
<pre><code>def tri_radix(l):
    v_max = max(l) # Nombre de passes à effectuer sur la liste
    significant_digit = 1 # Chiffre significatif / clé
    while v_max // significant_digit &gt; 0: # Fin quand il n'y a plus de chiffre significatif
        tri_denombrement(l, significant_digit) # Pour la distribution des éléments
        significant_digit *= 10 # changement de la clé pour les chiffres plus significatifs (dizaines, centaines, ...)
    return l
</code></pre>
<p>Le code complet de cet algorithme est fourni dans le dossier <em>src</em>, présent à la racine du dossier principal. L’algorithme du tri par dénombrement y est également présent, des appels à ces algorithmes peuvent donc être réalisés.</p>
<p>L’implémentation en Python de cet algorithme est relativement simple, surtout pour des entiers positifs. Des versions de l’algorithme de tri par dénombrement sur des entiers négatifs et des flottant existent cependant, et les modification qu’elles apportent se retrouvent notamment dans la partie liée au tri par dénombrement.</p>
<h3 id="etude-de-complexité">Etude de complexité</h3>
<p>Afin d’attester de la linéarité de l’algorithme de tri par base, nous avons fait le choix de mener une campagne d’expérimentations, dont la visualisation des courbes obtenues avec l’utilisation des modules <code>matplotlib</code> et <code>timeit</code> sur l’exécution de cet algorithme avec des listes d’entiers arrangées aléatoirement, par ordre croissant et par ordre décroissant de valeurs, prouverait l’obtention d’une telle complexité temporelle.</p>
<p>Ces tests ont été réalisés en Python, et les sources de ces derniers sont disponibles dans le dossier <em>src</em> lié à ce répertoire.</p>
<p><img src="img/radix.png" alt="" title="Figure 1"></p>
<p>Figure 1 : Courbe linéaire représentant les temps d’exécutions de 100 itérations du tri par base sur une liste d’entiers arrangés aléatoirement.</p>
<p><img src="img/sorts_melangee.png" alt="" title="Figure 2"></p>
<p>Figure 2 : Courbes représentant les temps d’exécutions de 100 itérations de différents tris (par comparaison et par distribution) sur une liste d’entiers arrangés aléatoirement.</p>
<p><img src="img/sorts_croissants.png" alt="" title="Figure 3"></p>
<p>Figure 3 : Courbes représentant les temps d’exécutions de 100 itérations de différents tris (par comparaison et par distribution) sur une liste d’entiers positifs arrangés selon un ordre croissant de valeurs.</p>
<p><img src="img/sorts_decroissants.png" alt="" title="Figure 4"></p>
<p>Figure 4 : Courbes représentant les temps d’exécutions de 100 itérations de différents tris (par comparaison et par distribution) sur une liste d’entiers positifs arrangés selon un ordre décroissant de valeurs.</p>
<p>Quelque soit l’arrangement initial de la liste passée en paramètre de notre fonction de rendu de courbes, il est aisé d’observer la linéarité temporelle du tri par base, par rapport à d’autre tris opérant par comparaison.</p>
</div>
</body>

</html>
